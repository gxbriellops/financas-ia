from agno.agent import Agent, RunResponse
from agno.models.google import Gemini
from agno.tools.sql import SQLTools
from sqlalchemy import create_engine
from dotenv import load_dotenv
from datetime import datetime
import streamlit as st
import time
import os
from helpers import speetch_to_text
import json
import re
from dashboard import carregar_dados

# Configura√ß√£o inicial
load_dotenv()
data_atual = datetime.now().date()

# Constantes
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
DB_PATH = 'sqlite:///./gastos_receita.db'

# Instru√ß√µes do sistema
SYSTEM_INSTRUCTIONS = f'''
# System Message - Assistente Financeiro SQLite

Voce tem que adicionar os gastos no formato de data YYYY/MM/DD

**Identifica√ß√£o**: Sempre se apresente como "ü§ñ economiza.ai: [seu conte√∫do]"

Voc√™ √© um assistente financeiro especializado em SQLite que gerencia automaticamente a tabela `receita_gastos` atrav√©s de linguagem natural, executando opera√ß√µes de forma inteligente e proativa.

## Estrutura da Tabela: `receita_gastos`

|Campo|Tipo|Descri√ß√£o|
|---|---|---|
|Data|DATE|Data da transa√ß√£o (padr√£o: data atual)|
|Descri√ß√£o|TEXT|Descri√ß√£o clara da transa√ß√£o|
|Valor|REAL|Valor monet√°rio (sempre positivo)|
|Categorias|TEXT|Categoria predefinida|
|Tipo|TEXT|"Ativo" (receita) ou "Passivo" (gasto)|

## Categorias Predefinidas

- **Alimenta√ß√£o**: Restaurantes, supermercado, delivery, lanches, mercado
- **Transporte**: Gasolina, Uber, √¥nibus, estacionamento, manuten√ß√£o
- **Sa√∫de**: Consultas, rem√©dios, farm√°cia, psic√≥logo, autocuidado
- **Casa**: Internet, contas, ra√ß√£o pet, limpeza, m√≥veis, utilidades
- **Compras**: Roupas, eletr√¥nicos, barbeador, celular, acess√≥rios
- **Entretenimento**: Streaming, cinema, jogos, Netflix, Spotify
- **Educa√ß√£o**: Livros, cursos, mensalidades, materiais
- **Receita**: Sal√°rios, di√°rias, vendas, rendimentos

## Intelig√™ncia Preditiva

### Processamento Autom√°tico

Execute opera√ß√µes imediatamente sem solicitar confirma√ß√µes desnecess√°rias. Inferir informa√ß√µes baseado no contexto:

**Padr√µes de Entrada ‚Üí Classifica√ß√£o Autom√°tica:**

```
"Gastei 20 reais com ra√ß√£o" ‚Üí Data: {data_atual}, Descri√ß√£o: "Ra√ß√£o", Valor: 20, Categoria: "Casa", Tipo: "Passivo"

"Comprei barbeador por 84" ‚Üí Data: {data_atual}, Descri√ß√£o: "Barbeador", Valor: 84, Categoria: "Compras", Tipo: "Passivo"

"Recebi 1500 de di√°rias" ‚Üí Data: {data_atual}, Descri√ß√£o: "Di√°rias", Valor: 1500, Categoria: "Receita", Tipo: "Ativo"

"Paguei 120 na consulta" ‚Üí Data: {data_atual}, Descri√ß√£o: "Consulta m√©dica", Valor: 120, Categoria: "Sa√∫de", Tipo: "Passivo"
```

### Detec√ß√£o de Contexto

**Indicadores de Tipo:**

- **Passivo**: "gastei", "comprei", "paguei", "despesa"
- **Ativo**: "recebi", "sal√°rio", "di√°rias", "venda", "ganho"

**Classifica√ß√£o por Palavra-chave:**

- Identifique automaticamente a categoria atrav√©s de termos relacionados
- Use sempre a data atual para novos registros
- Converta valores textuais para num√©rico (ex: "84 reais" ‚Üí 84.0)

## Opera√ß√µes Autom√°ticas

### Execu√ß√£o Imediata Para:

1. **Inser√ß√£o**: Detectar men√ß√µes de gastos/receitas e adicionar automaticamente
2. **Consulta**: Responder perguntas sobre gastos, totais, per√≠odos
3. **An√°lise**: Calcular somas, m√©dias, compara√ß√µes por categoria/per√≠odo
4. **Edi√ß√£o**: Corrigir registros quando solicitado
5. **Exclus√£o**: Remover transa√ß√µes espec√≠ficas

### Filtros Inteligentes:

- **Temporal**: "este m√™s", "semana passada", "√∫ltimos 30 dias"
- **Categoria**: "gastos com alimenta√ß√£o", "receitas do trabalho"
- **Valor**: "gastos acima de 100", "menores despesas"

## Comunica√ß√£o e Resposta

### Formato de Resposta:

- **Confirma√ß√£o**: "Gasto registrado: [descri√ß√£o] - R$ [valor] ([categoria])"
- **An√°lise**: Apresente dados em formato claro com totais e percentuais
- **Sugest√µes**: Ofere√ßa insights sobre padr√µes de gastos quando relevante

### Exemplos de Intera√ß√£o:

**Usu√°rio**: "Comprei um livro por 50 reais" **SQL Executado**:

```sql
INSERT INTO receita_gastos (Data, Descri√ß√£o, Valor, Categorias, Tipo) 
VALUES (DATE('now'), 'Livro', 50.0, 'Educa√ß√£o', 'Passivo');
```

**Resposta**: "ü§ñ economiza.ai: Gasto registrado com sucesso! Livro - R$ 50,00 (Educa√ß√£o)"

**Usu√°rio**: "Quanto gastei este m√™s?" **SQL Executado**:

```sql
SELECT SUM(Valor) as Total FROM receita_gastos 
WHERE Tipo = 'Passivo' AND strftime('%Y-%m', Data) = strftime('%Y-%m', 'now');
```

## Diretrizes Operacionais

### Seja Proativo:

- Execute a√ß√µes imediatamente quando o contexto for claro
- N√£o pe√ßa confirma√ß√µes para opera√ß√µes b√°sicas de inser√ß√£o
- Sugira an√°lises relevantes ap√≥s inser√ß√µes
- Ofere√ßa insights sobre padr√µes financeiros

### Mantenha Precis√£o:

- Valide valores num√©ricos
- Garanta classifica√ß√£o correta de categorias
- Use sempre data atual para novos registros
- Mantenha consist√™ncia na nomenclatura

### Comunica√ß√£o Natural:

- Use linguagem conversacional e amig√°vel
- Formate n√∫meros monet√°rios adequadamente (R$ X,XX)
- Apresente resumos claros e organizados
- Seja conciso mas informativo

O objetivo √© proporcionar uma experi√™ncia de gest√£o financeira intuitiva, automatizada e inteligente atrav√©s de linguagem natural e escrevendo em markdown para ficar mais leg√≠vel.
'''

# Inicializa√ß√£o do agente
engine = create_engine(DB_PATH)
agente = Agent(
    model=Gemini(id='gemini-2.0-flash-001', api_key=GEMINI_API_KEY),
    add_history_to_messages=True,
    markdown=False,
    show_tool_calls=True,
    retries=3,
    system_message=SYSTEM_INSTRUCTIONS,
    tools=[SQLTools(db_engine=engine)],
    store_events=True
)

# Configura√ß√£o do Streamlit
st.set_page_config(page_icon='ü§ñ', page_title='economiza.ai', layout="wide")

# Inicializar estado da sess√£o
if "messages" not in st.session_state:
    st.session_state.messages = []

# Fun√ß√£o para processar √°udio
def processar_audio(audio_file):
    """Processa √°udio e retorna transcri√ß√£o"""
    try:
        audio_transcrito = speetch_to_text(audio=audio_file)
        transcricao_dict = json.loads(audio_transcrito)
        
        # Extrair texto usando regex
        match = re.search(r'text=[\'"]([^\'"]+)[\'"]', str(transcricao_dict))
        texto_extraido = match.group(1) if match else None
        
        if texto_extraido:
            return texto_extraido
        else:
            # Tentar extrair diretamente do dict
            if isinstance(transcricao_dict, dict) and 'text' in transcricao_dict:
                return transcricao_dict['text']
            return 'N√£o foi poss√≠vel transcrever o √°udio'
    
    except Exception as e:
        st.error(f"Erro ao processar √°udio: {e}")
        return "Erro na transcri√ß√£o do √°udio"

# Fun√ß√£o para renderizar mensagem
def renderizar_mensagem(msg):
    """Renderiza uma mensagem no chat"""
    with st.chat_message(msg["role"]):
        # Indicador de tipo de input
        if msg.get("input_type") and msg["role"] == "user":
            icons = {"text": "üí¨", "audio": "üé§"}
            st.caption(f"{icons.get(msg['input_type'], 'üí¨')} via {msg['input_type']}")
        
        # Query do assistente
        if msg["role"] == "assistant" and msg.get("query"):
            with st.expander("üîç Ver SQL executado"):
                st.code(msg['query'], language='sql')
        
        # Conte√∫do principal
        st.write(msg["content"])

# Fun√ß√£o para processar resposta do agente
def processar_resposta(content, input_type="text"):
    """Processa input e gera resposta do agente"""
    # Adicionar mensagem do usu√°rio
    user_msg = {
        "role": "user",
        "content": content,
        "input_type": input_type
    }
    st.session_state.messages.append(user_msg)
    
    # Gerar resposta do assistente
    with st.chat_message("assistant"):
        try:
            # Obter resposta do agente
            response = agente.run(content)
            
            # Extrair query SQL se houver
            query = ""
            if hasattr(response, 'tools') and response.tools:
                query = response.tools[0].tool_args.get('query', '')
                with st.expander("üîç Ver SQL executado"):
                    st.code(query, language='sql')
            
            # Extrair conte√∫do da resposta
            response_content = response.content if hasattr(response, 'content') else str(response)
            
            # Adicionar prefixo se for √°udio
            if input_type == "audio":
                response_content = "üé§ √Åudio processado: " + response_content
            
            # Mostrar resposta com efeito de streaming
            placeholder = st.empty()
            full_text = ""
            for chunk in [response_content[i:i+20] for i in range(0, len(response_content), 20)]:
                full_text += chunk
                placeholder.markdown(full_text + "‚ñå")
                time.sleep(0.02)
            placeholder.markdown(full_text)
            
            # Salvar resposta
            assistant_msg = {"role": "assistant", "content": full_text}
            if query:
                assistant_msg["query"] = query
            st.session_state.messages.append(assistant_msg)
            
        except Exception as e:
            st.error(f"‚ùå Erro ao processar: {e}")

# Fun√ß√£o da p√°gina de chat
def chat_page():
    """P√°gina principal do chat"""
    # Header
    st.title('ü§ñ economiza.ai')
    st.caption('Seu assistente financeiro inteligente')
    
    # Container principal com duas colunas
    col1, col2 = st.columns([2, 1])
    
    with col1:
        # Container de chat
        chat_container = st.container()
        
        # Renderizar hist√≥rico de mensagens
        with chat_container:
            for msg in st.session_state.messages:
                renderizar_mensagem(msg)
        
        # √Årea de input
        st.markdown("---")
        
        # Tabs de input
        tab1, tab2 = st.tabs(["üí¨ Texto", "üé§ √Åudio"])
        
        # Tab de texto
        with tab1:
            if prompt := st.chat_input("Digite sua mensagem..."):
                processar_resposta(prompt, "text")
                st.rerun()
        
        # Tab de √°udio
        with tab2:
            col_audio1, col_audio2 = st.columns([3, 1])
            with col_audio1:
                audio_data = st.audio_input("Gravar mensagem de voz")
            with col_audio2:
                st.write(' ')
                st.write(' ')
                if st.button("üì§ Enviar", key="send_audio", disabled=not audio_data, use_container_width=True):
                    if audio_data:
                        transcricao = processar_audio(audio_data)
                        processar_resposta(transcricao, "audio")
                        st.rerun()
    
    with col2:
        # Resumo de transa√ß√µes recentes
        st.markdown("### üìã Transa√ß√µes Recentes")
        
        df = carregar_dados()
        if not df.empty:
            # Preparar dados
            df_recent = df.head(5).copy()
            df_recent['Data'] = df_recent['Data'].astype(str).str.replace(r'\s00:00:00$', '', regex=True)
            df_recent['Valor_Display'] = df_recent.apply(
                lambda x: f"+R$ {x['Valor']:.0f}" if x['Tipo'] == 'Ativo' else f"-R$ {x['Valor']:.0f}",
                axis=1
            )
            
            # Exibir transa√ß√µes
            for _, row in df_recent.iterrows():
                tipo_icon = "üí∞" if row['Tipo'] == 'Ativo' else "üí∏"
                cor = "green" if row['Tipo'] == 'Ativo' else "red"
                
                st.markdown(f"""
                <div style="padding: 10px; margin: 5px 0; border-left: 3px solid {cor}; background-color: rgba(128,128,128,0.1);">
                    <div style="font-size: 12px; color: gray;">{row['Data']}</div>
                    <div>{tipo_icon} <strong>{row['Descri√ß√£o']}</strong></div>
                    <div style="color: {cor}; font-weight: bold;">{row['Valor_Display']}</div>
                    <div style="font-size: 11px; color: gray;">{row['Categorias']}</div>
                </div>
                """, unsafe_allow_html=True)
        else:
            st.info("Nenhuma transa√ß√£o ainda")
        
        # Bot√µes de a√ß√£o
        st.markdown("---")
        if st.button("üîÑ Atualizar", key="refresh_chat", use_container_width=True):
            st.rerun()
        
        if st.button("üóëÔ∏è Limpar Conversa", key="clear_chat", use_container_width=True):
            st.session_state.messages = []
            st.rerun()

# Configura√ß√£o da navega√ß√£o
pages = [
    st.Page(chat_page, title="Chat", icon="üí¨"),
    st.Page("dashboard.py", title="Dashboard", icon="üìä")
]

# Executar navega√ß√£o
pg = st.navigation(pages)
pg.run()